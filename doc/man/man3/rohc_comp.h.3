.\" File automatically generated by doxy2man0.1
.\" Generation date: dim. ao√ªt 9 2015
.TH rohc_comp.h 3 2015-08-09 "ROHC" "ROHC library Programmer's Manual"
.SH "NAME"
rohc_comp.h \- The ROHC compression API
.SH SYNOPSIS
.nf
.B #include <rohc/rohc_comp.h>
.fi
.SH DESCRIPTION
.PP 
The compression API of the ROHC library allows a program to compress the protocol headers of some uncompressed packets into ROHC packets.
.PP 
The program shall first create a compressor context and configure it. It then may compress as many packets as needed. When done, the ROHC compressor context shall be destroyed. 
.PP
.sp
.RS
.nf
\fB
struct rohc_comp  *rohc_alloc_compressor(int max_cid,
                                         int jam_use,
                                         int adapt_size,
                                         int encap_size);
void               rohc_free_compressor(struct rohc_comp * comp);
struct rohc_comp  *rohc_comp_new(const rohc_cid_type_t cid_type,
                                 const rohc_cid_t max_cid);
struct rohc_comp  *rohc_comp_new2(const rohc_cid_type_t cid_type,
                                  const rohc_cid_t max_cid,
                                  const rohc_comp_random_cb_t rand_cb,
                                  void *const rand_priv);
void               rohc_comp_free(struct rohc_comp *const comp);
bool               rohc_comp_set_traces_cb(struct rohc_comp *const comp,
                                           rohc_trace_callback_t callback);
bool               rohc_comp_set_traces_cb2(struct rohc_comp *const comp,
                                            rohc_trace_callback2_t callback,
                                            void *const priv_ctxt);
bool               rohc_comp_set_random_cb(struct rohc_comp *const comp,
                                           rohc_comp_random_cb_t callback,
                                           void *const user_context);
int                rohc_compress(struct rohc_comp * comp,
                                 unsigned char * ibuf,
                                 int isize,
                                 unsigned char * obuf,
                                 int osize);
int                rohc_compress2(struct rohc_comp *const comp,
                                  const unsigned char *const uncomp_packet,
                                  const size_t uncomp_packet_len,
                                  unsigned char *const rohc_packet,
                                  const size_t rohc_packet_max_len,
                                  size_t *const rohc_packet_len);
int                rohc_compress3(struct rohc_comp *const comp,
                                  const struct rohc_ts arrival_time,
                                  const unsigned char *const uncomp_packet,
                                  const size_t uncomp_packet_len,
                                  unsigned char *const rohc_packet,
                                  const size_t rohc_packet_max_len,
                                  size_t *const rohc_packet_len);
rohc_status_t      rohc_compress4(struct rohc_comp *const comp,
                                  const struct rohc_buf uncomp_packet,
                                  struct rohc_buf *const rohc_packet);
int                rohc_comp_get_segment(struct rohc_comp *const comp,
                                         unsigned char *const segment,
                                         const size_t max_len,
                                         size_t *const len);
rohc_status_t      rohc_comp_get_segment2(struct rohc_comp *const comp,
                                          struct rohc_buf *const segment);
bool               rohc_comp_force_contexts_reinit(struct rohc_comp *const comp);
bool               rohc_comp_set_wlsb_window_width(struct rohc_comp *const comp,
                                                   const size_t width);
bool               rohc_comp_set_periodic_refreshes(struct rohc_comp *const comp,
                                                    const size_t ir_timeout,
                                                    const size_t fo_timeout);
bool               rohc_comp_set_list_trans_nr(struct rohc_comp *const comp,
                                               const size_t list_trans_nr);
bool               rohc_comp_set_rtp_detection_cb(struct rohc_comp *const comp,
                                                  rohc_rtp_detection_callback_t callback,
                                                  void *const rtp_private);
bool               rohc_comp_profile_enabled(const struct rohc_comp *const comp,
                                             const rohc_profile_t profile);
void               rohc_activate_profile(struct rohc_comp * comp,
                                         int profile);
bool               rohc_comp_enable_profile(struct rohc_comp *const comp,
                                            const rohc_profile_t profile);
bool               rohc_comp_disable_profile(struct rohc_comp *const comp,
                                             const rohc_profile_t profile);
bool               rohc_comp_enable_profiles(struct rohc_comp *const comp,
                                              ...);
bool               rohc_comp_disable_profiles(struct rohc_comp *const comp,
                                               ...);
int                rohc_c_using_small_cid(struct rohc_comp * comp);
void               rohc_c_set_header(struct rohc_comp * comp,
                                     int header);
void               rohc_c_set_mrru(struct rohc_comp * comp,
                                   int value);
bool               rohc_comp_set_mrru(struct rohc_comp *const comp,
                                      const size_t mrru);
bool               rohc_comp_get_mrru(const struct rohc_comp *const comp,
                                      size_t *const mrru);
void               rohc_c_set_max_cid(struct rohc_comp * comp,
                                      int value);
bool               rohc_comp_get_max_cid(const struct rohc_comp *const comp,
                                         size_t *const max_cid);
void               rohc_c_set_large_cid(struct rohc_comp * comp,
                                        int large_cid);
bool               rohc_comp_get_cid_type(const struct rohc_comp *const comp,
                                          rohc_cid_type_t *const cid_type);
bool               rohc_comp_add_rtp_port(struct rohc_comp *const comp,
                                          const unsigned int port);
bool               rohc_comp_remove_rtp_port(struct rohc_comp *const comp,
                                             const unsigned int port);
bool               rohc_comp_reset_rtp_ports(struct rohc_comp *const comp);
bool               rohc_comp_set_features(struct rohc_comp *const comp,
                                          const rohc_comp_features_t features);
void               rohc_c_set_enable(struct rohc_comp * comp,
                                     int enable);
int                rohc_c_is_enabled(struct rohc_comp * comp);
int                rohc_c_info(char * buffer);
int                rohc_c_statistics(struct rohc_comp * comp,
                                     unsigned int indent,
                                     char * buffer);
void               c_piggyback_feedback(struct rohc_comp * comp,
                                        unsigned char * feedback,
                                        int size);
bool               rohc_comp_piggyback_feedback(struct rohc_comp *const comp,
                                                const unsigned char *const feedback,
                                                const size_t size);
void               c_deliver_feedback(struct rohc_comp * comp,
                                      unsigned char * packet,
                                      int size);
bool               rohc_comp_deliver_feedback(struct rohc_comp *const comp,
                                              const uint8_t *const packet,
                                              const size_t size);
bool               rohc_comp_deliver_feedback2(struct rohc_comp *const comp,
                                               const struct rohc_buf feedback);
int                rohc_feedback_flush(struct rohc_comp * comp,
                                       unsigned char * obuf,
                                       int osize);
size_t             rohc_feedback_avail_bytes(const struct rohc_comp *const comp);
int                rohc_comp_get_last_packet_info(const struct rohc_comp *const comp,
                                                  rohc_comp_last_packet_info_t *const info);
bool               rohc_comp_get_last_packet_info2(const struct rohc_comp *const comp,
                                                   rohc_comp_last_packet_info2_t *const info);
bool               rohc_comp_get_general_info(const struct rohc_comp *const comp,
                                              rohc_comp_general_info_t *const info);
const char        *rohc_comp_get_state_descr(const rohc_comp_state_t state);
bool               rohc_feedback_remove_locked(struct rohc_comp *const comp);
bool               rohc_feedback_unlock(struct rohc_comp *const comp);
\fP
.fi
.RE
.SH STRUCTURES
.SS "The different ROHC compressor states"
.PP
.sp
.PP 
The different ROHC operation states at compressor as defined in section 4.3.1 of RFC 3095.
.PP 
If you add a new compressor state, please also add the corresponding textual description in \fBrohc_comp_get_state_descr\fP.
.PP 
do not use this type anymore, use rohc_comp_state_t instead
.sp
.RS
.nf
enum \fBrohc_c_state\fP {
  \fIIR\fP, /* The Initialization and Refresh (IR) compressor state */
  \fIFO\fP, /* The First Order (FO) compressor state */
  \fISO\fP, /* The Second Order (SO) compressor state */
};
.fi
.RE
.SS "The different ROHC compressor states"
.PP
.sp
.PP 
The different ROHC operation states at compressor as defined in section 4.3.1 of RFC 3095.
.PP 
If you add a new compressor state, please also add the corresponding textual description in \fBrohc_comp_get_state_descr\fP.
.sp
.RS
.nf
enum \fBrohc_comp_state_t\fP {
  \fIROHC_COMP_STATE_IR\fP, /* The Initialization and Refresh (IR) compressor state */
  \fIROHC_COMP_STATE_FO\fP, /* The First Order (FO) compressor state */
  \fIROHC_COMP_STATE_SO\fP, /* The Second Order (SO) compressor state */
};
.fi
.RE
.SS "The different features of the ROHC compressor"
.PP
.sp
.PP 
Features for the ROHC compressor control whether mechanisms defined as optional by RFCs are enabled or not. They can be set or unset with the function \fBrohc_comp_set_features\fP.
.sp
.RS
.nf
enum \fBrohc_comp_features_t\fP {
  \fIROHC_COMP_FEATURE_NONE\fP,            /* No feature at all */
  \fIROHC_COMP_FEATURE_COMPAT_1_6_x\fP,    /* Be compatible with 1.6.x versions */
  \fIROHC_COMP_FEATURE_NO_IP_CHECKSUMS\fP, /* Do not check IP checksums at compressor */
};
.fi
.RE
.SS "The prototype of the RTP detection callback"
.PP
.sp
.PP 
User-defined function that is called by the ROHC library for every UDP packet to determine whether the UDP packet transports RTP data. If the function returns true, the RTP profile is used to compress the packet. Otherwise the UDP profile is used.
.PP 
The user-defined function is set by calling the function \fBrohc_comp_set_rtp_detection_cb\fP
.PP 
Return true if the packet is an RTP packet, false otherwise
.sp
.RS
.nf
typedef bool (*\fBrohc_rtp_detection_callback_t\fP) (
    \fBconst unsigned char *const  ip\fP,           /* The innermost IP packet */
    \fBconst unsigned char *const  udp\fP,          /* The UDP header of the packet */
    \fBconst unsigned char *const  payload\fP,      /* The UDP payload of the packet */
    \fBconst unsigned int          payload_size\fP, /* The size of the UDP payload (in bytes) */
    \fBvoid *const                 rtp_private\fP   /* A pointer to a memory area to be used by the callback function, may be NULL. */
.fi
);
.fi
.SS "The prototype of the callback for random numbers"
.PP
.sp
.PP 
User-defined function that is called when the ROHC library requires a random number. Currently, the ROHC library uses it when initializing the Sequence Number (SN) of contexts using the IP-only, IP/UDP, and IP/UDP-Lite profiles.
.PP 
The user-defined function is set by calling the function \fBrohc_comp_set_random_cb\fP
.sp
.RS
.nf
typedef int (*\fBrohc_comp_random_cb_t\fP) (
    \fBconst struct rohc_comp *const  comp\fP,         /* The ROHC compressor */
    \fBvoid *const                    user_context\fP  /* The context given by the user when he/she called the rohc_comp_set_random_cb function, may be NULL. */
.fi
);
.fi
.SS "A timestamp for the ROHC library"
.PP
.sp
.PP 
Could be easily created from \fBstruct\fP \fBtimespec\fP...
.PP 
 
.sp
.RS
.nf
struct \fBrohc_ts\fP {
  uint64_t \fIsec\fP;  /* The seconds part of the timestamp */
  uint64_t \fInsec\fP; /* The nanoseconds part of the timestamp */
};
.fi
.RE
.SS "Some information about the last compressed packet"
.PP
.sp
.PP 
Non-extensible version of rohc_comp_last_packet_info2_t
.PP 
do not use this struct anymore, use rohc_comp_last_packet_info2_t instead
.sp
.RS
.nf
struct \fBrohc_comp_last_packet_info_t\fP {
  rohc_mode_t       \fIcontext_mode\fP;            /* Compression mode */
  rohc_comp_state_t \fIcontext_state\fP;           /* Compression state */
  rohc_packet_t     \fIpacket_type\fP;             /* Packet type */
  unsigned long     \fItotal_last_uncomp_size\fP;  /* Uncompressed packet size (bytes) */
  unsigned long     \fIheader_last_uncomp_size\fP; /* Uncompressed header size (bytes) */
  unsigned long     \fItotal_last_comp_size\fP;    /* Compressed packet size (bytes) */
  unsigned long     \fIheader_last_comp_size\fP;   /* Compressed header size (bytes) */
};
.fi
.RE
.SS "Some information about the last compressed packet"
.PP
.sp
.PP 
The structure is used by the \fBrohc_comp_get_last_packet_info2\fP function to store some information about the last compressed packet.
.PP 
Versioning works as follow:
.PP 
.RS
.PP 
\(bu The \fBversion_major\fP field defines the compatibility level. If the major number given by user does not match the one expected by the library, an error is returned.
.PP 
\(bu The \fBversion_minor\fP field defines the extension level. If the minor number given by user does not match the one expected by the library, only the fields supported in that minor version will be filled by \fBrohc_comp_get_last_packet_info2\fP.
.PP 
.RE
.PP 
Notes for developers:
.PP 
.RS
.PP 
\(bu Increase the major version if a field is removed.
.PP 
\(bu Increase the major version if a field is added at the beginning or in the middle of the structure.
.PP 
\(bu Increase the minor version if a field is added at the very end of the structure.
.PP 
\(bu The version_major and version_minor fields must be located at the very beginning of the structure.
.PP 
\(bu The structure must be packed.
.PP 
.RE
.PP 
Supported versions:
.PP 
.RS
.PP 
\(bu Major 0 / Minor 0 contains: version_major, version_minor, context_id, is_context_init, context_mode, context_state, context_used, profile_id, packet_type, total_last_uncomp_size, header_last_uncomp_size, total_last_comp_size, and header_last_comp_size
.PP 
.RE
.sp
.RS
.nf
struct \fBrohc_comp_last_packet_info2_t\fP {
  unsigned short    \fIversion_major\fP;           /* The major version of this structure */
  unsigned short    \fIversion_minor\fP;           /* The minor version of this structure */
  unsigned int      \fIcontext_id\fP;              /* The Context ID (CID) */
  bool              \fIis_context_init\fP;         /* Whether the context was initialized (created/re-used) by the packet */
  rohc_mode_t       \fIcontext_mode\fP;            /* The mode of the last context used by the compressor */
  rohc_comp_state_t \fIcontext_state\fP;           /* The state of the last context used by the compressor */
  bool              \fIcontext_used\fP;            /* Whether the last context used by the compressor is still in use */
  int               \fIprofile_id\fP;              /* The profile ID of the last context used by the compressor */
  rohc_packet_t     \fIpacket_type\fP;             /* The type of ROHC packet created for the last compressed packet */
  unsigned long     \fItotal_last_uncomp_size\fP;  /* The uncompressed size (in bytes) of the last compressed packet */
  unsigned long     \fIheader_last_uncomp_size\fP; /* The uncompressed size (in bytes) of the last compressed header */
  unsigned long     \fItotal_last_comp_size\fP;    /* The compressed size (in bytes) of the last compressed packet */
  unsigned long     \fIheader_last_comp_size\fP;   /* The compressed size (in bytes) of the last compressed header */
};
.fi
.RE
.SS "Some general information about the compressor"
.PP
.sp
.PP 
The structure is used by the \fBrohc_comp_get_general_info\fP function to store some general information about the compressor.
.PP 
Versioning works as follow:
.PP 
.RS
.PP 
\(bu The \fBversion_major\fP field defines the compatibility level. If the major number given by user does not match the one expected by the library, an error is returned.
.PP 
\(bu The \fBversion_minor\fP field defines the extension level. If the minor number given by user does not match the one expected by the library, only the fields supported in that minor version will be filled by \fBrohc_comp_get_general_info\fP.
.PP 
.RE
.PP 
Notes for developers:
.PP 
.RS
.PP 
\(bu Increase the major version if a field is removed.
.PP 
\(bu Increase the major version if a field is added at the beginning or in the middle of the structure.
.PP 
\(bu Increase the minor version if a field is added at the very end of the structure.
.PP 
\(bu The version_major and version_minor fields must be located at the very beginning of the structure.
.PP 
\(bu The structure must be packed.
.PP 
.RE
.PP 
Supported versions:
.PP 
.RS
.PP 
\(bu major 0 and minor = 0 contains: version_major, version_minor, contexts_nr, packets_nr, uncomp_bytes_nr, and comp_bytes_nr.
.PP 
.RE
.sp
.RS
.nf
struct \fBrohc_comp_general_info_t\fP {
  unsigned short \fIversion_major\fP;   /* The major version of this structure */
  unsigned short \fIversion_minor\fP;   /* The minor version of this structure */
  size_t         \fIcontexts_nr\fP;     /* The number of contexts used by the compressor */
  unsigned long  \fIpackets_nr\fP;      /* The number of packets processed by the compressor */
  unsigned long  \fIuncomp_bytes_nr\fP; /* The number of uncompressed bytes received by the compressor */
  unsigned long  \fIcomp_bytes_nr\fP;   /* The number of compressed bytes produced by the compressor */
};
.fi
.RE
.SS "A network buffer for the ROHC library"
.PP
.sp
.PP 
May represent one uncompressed packet, one ROHC packet, or a ROHC feedback.
.PP 
The network buffer does not contain the packet data itself. It only has a pointer on it. This is designed this way for performance reasons: no copy required to initialize a network buffer, the struct is small and may be passed as copy to function.
.PP 
The network buffer is able to keep some free space at its beginning. The unused space at the beginning of the buffer may be used to prepend a network header at the very end of the packet handling.
.PP 
The beginning of the network buffer may also be shifted forward with the \fBrohc_buf_pull\fP function or shifted backward with the \fBrohc_buf_push\fP function. This is useful when parsing a network packet (once bytes are read, shift them forward) for example.
.PP 
The network buffer may be initialized manually (see below) or with the helper functions \fBrohc_buf_init_empty\fP or \fBrohc_buf_init_full\fP...
.PP 
...
.PP 
 
.sp
.RS
.nf
struct \fBrohc_buf\fP {
  struct rohc_ts \fItime\fP;    /* The timestamp associated to the data */
  uint8_t       *\fIdata\fP;    /* The buffer data */
  size_t         \fImax_len\fP; /* The maximum length of the buffer */
  size_t         \fIoffset\fP;  /* The offset for the beginning of the data */
  size_t         \fIlen\fP;     /* The data length (in bytes) */
};
.fi
.RE
.SH SEE ALSO
.BR rohc_alloc_compressor (3),
.BR rohc_free_compressor (3),
.BR rohc_comp_new (3),
.BR rohc_comp_new2 (3),
.BR rohc_comp_free (3),
.BR rohc_comp_set_traces_cb (3),
.BR rohc_comp_set_traces_cb2 (3),
.BR rohc_comp_set_random_cb (3),
.BR rohc_compress (3),
.BR rohc_compress2 (3),
.BR rohc_compress3 (3),
.BR rohc_compress4 (3),
.BR rohc_comp_get_segment (3),
.BR rohc_comp_get_segment2 (3),
.BR rohc_comp_force_contexts_reinit (3),
.BR rohc_comp_set_wlsb_window_width (3),
.BR rohc_comp_set_periodic_refreshes (3),
.BR rohc_comp_set_list_trans_nr (3),
.BR rohc_comp_set_rtp_detection_cb (3),
.BR rohc_comp_profile_enabled (3),
.BR rohc_activate_profile (3),
.BR rohc_comp_enable_profile (3),
.BR rohc_comp_disable_profile (3),
.BR rohc_comp_enable_profiles (3),
.BR rohc_comp_disable_profiles (3),
.BR rohc_c_using_small_cid (3),
.BR rohc_c_set_header (3),
.BR rohc_c_set_mrru (3),
.BR rohc_comp_set_mrru (3),
.BR rohc_comp_get_mrru (3),
.BR rohc_c_set_max_cid (3),
.BR rohc_comp_get_max_cid (3),
.BR rohc_c_set_large_cid (3),
.BR rohc_comp_get_cid_type (3),
.BR rohc_comp_add_rtp_port (3),
.BR rohc_comp_remove_rtp_port (3),
.BR rohc_comp_reset_rtp_ports (3),
.BR rohc_comp_set_features (3),
.BR rohc_c_set_enable (3),
.BR rohc_c_is_enabled (3),
.BR rohc_c_info (3),
.BR rohc_c_statistics (3),
.BR c_piggyback_feedback (3),
.BR rohc_comp_piggyback_feedback (3),
.BR c_deliver_feedback (3),
.BR rohc_comp_deliver_feedback (3),
.BR rohc_comp_deliver_feedback2 (3),
.BR rohc_feedback_flush (3),
.BR rohc_feedback_avail_bytes (3),
.BR rohc_comp_get_last_packet_info (3),
.BR rohc_comp_get_last_packet_info2 (3),
.BR rohc_comp_get_general_info (3),
.BR rohc_comp_get_state_descr (3),
.BR rohc_feedback_remove_locked (3),
.BR rohc_feedback_unlock (3)
