.\" File automatically generated by doxy2man0.1
.\" Generation date: dim. ao√ªt 9 2015
.TH rohc_comp_get_segment 3 2015-08-09 "ROHC" "ROHC library Programmer's Manual"
.SH "NAME"
rohc_comp_get_segment \- Get the next ROHC segment if any.
.SH SYNOPSIS
.nf
.B #include <rohc/rohc_comp.h>
.sp
\fBint rohc_comp_get_segment\fP(
    \fBstruct rohc_comp *const  comp\fP,
    \fBunsigned char *const     segment\fP,
    \fBconst size_t             max_len\fP,
    \fBsize_t *const            len\fP
);
.fi
.SH DESCRIPTION
.PP 
Get the next ROHC segment if any.
.PP 
To get all the segments of one ROHC packet, call this function until \fBROHC_OK\fP or \fBROHC_ERROR\fP is returned.
.PP 
please do not use this function anymore, use rohc_comp_get_segment2() instead
.SH PARAMETERS
.TP
.B comp
The ROHC compressor 
.TP
.B segment
The buffer where to store the ROHC segment 
.TP
.B max_len
The maximum length (in bytes) of the buffer for the ROHC segment 
.TP
.B len [output]
The length (in bytes) of the ROHC segment 
.SH STRUCTURES
.SH RETURN VALUE
.PP
Possible return values: 
.RS

\(bu \fBROHC_NEED_SEGMENT\fP if a ROHC segment is returned and more segments are available, 

\(bu \fBROHC_OK\fP if a ROHC segment is returned and no more ROHC segment is available 

\(bu \fBROHC_ERROR\fP if an error occurred


.RE


.SH EXAMPLE
.nf
struct rohc_comp *comp;

ess the IP packet with a small ROHC buffer
status = rohc_compress4(comp, ip_packet, &rohc_packet);
if(status == ROHC_STATUS_SEGMENT)
{
        /* ROHC segmentation is required to compress the IP packet */
        /* get the segments */
        while((status = rohc_comp_get_segment2(comp, &rohc_packet)) == ROHC_STATUS_SEGMENT)
        {
                /* new ROHC segment retrieved */

press the ROHC segment here, the function
decompress4 shall return
NON_FINAL_SEGMENT

                if(uncomp_packet.len > 0)
                {
                        fprintf(stderr, "\tdecompression of ROHC segment succeeded while "
                                "it should have not\n");
                        goto destroy_decomp;
                }
                rohc_packet.len = 0;
        }
        if(status != ROHC_STATUS_OK)
        {
                fprintf(stderr, "failed to generate ROHC segment (status = %d)\n",
                        status);
                goto destroy_decomp;
        }
        /* final ROHC segment retrieved */
press the final ROHC segment here, the function
decompress4 shall return ROHC_OK
        if(uncomp_packet.len == 0)
        {
                fprintf(stderr, "\tdecompression of ROHC segment failed while it "
                        "should have succeeded\n");
                goto destroy_decomp;
        }
}
else if(status != ROHC_STATUS_OK)
{
e compression error here




.fi
.SH SEE ALSO
.BR rohc_comp.h (3),
.BR ROHC_OK (3),
.BR ROHC_ERROR (3),
.BR ROHC_NEED_SEGMENT (3),
.BR rohc_comp_get_mrru (3),
.BR rohc_comp_set_mrru (3),
.BR rohc_compress4 (3)
